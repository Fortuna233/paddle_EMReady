def align(depoMap, simuMap):
    # 转换输入为PyTorch张量
    depoMap = torch.from_numpy(depoMap)
    simuMap = torch.from_numpy(simuMap)

    # 获取两个三维张量的原始尺寸
    depo_shape = depoMap.shape
    simu_shape = simuMap.shape
    
    # 计算FFT优化所需填充尺寸（避免循环卷积）
    # 根据信号处理理论，正确尺寸应为原始尺寸之和减1
    padded_shape = (
        depo_shape[0] + simu_shape[0] - 1,
        depo_shape[1] + simu_shape[1] - 1,
        depo_shape[2] + simu_shape[2] - 1
    )
    
    # 对两个信号进行零填充（将原始数据放在左上角）
    depo_padded = torch.zeros(padded_shape, dtype=depoMap.dtype)
    depo_padded[:depo_shape[0], :depo_shape[1], :depo_shape[2]] = depoMap
    
    simu_padded = torch.zeros(padded_shape, dtype=simuMap.dtype)
    simu_padded[:simu_shape[0], :simu_shape[1], :simu_shape[2]] = simuMap
    
    # 执行FFT优化互相关计算
    # --------------------------------------------
    # 步骤1: 计算三维快速傅里叶变换
    fft_depo = torch.fft.fftn(depo_padded)
    fft_simu = torch.fft.fftn(simu_padded)
    
    # 步骤2: 频域相乘（取其中一个的共轭实现互相关）
    corr_freq = fft_depo * torch.conj(fft_simu)
    
    # 步骤3: 逆FFT返回时域相关图
    corr = torch.fft.ifftn(corr_freq).real  # 取实部舍去浮点误差虚部
    # --------------------------------------------
    
    # 找到最大响应位置（原始conv3d等效结果）
    max_idx = torch.argmax(corr)
    dx, dy, dz = np.unravel_index(max_idx.numpy(), corr.shape)
    
    # 计算实际偏移量（考虑FFT填充带来的位置偏移）
    # 公式：offset = peak_pos - (kernel_size - 1)
    offset_x = dx - (simu_shape[0] - 1)
    offset_y = dy - (simu_shape[1] - 1)
    offset_z = dz - (simu_shape[2] - 1)
    
    # 边界保护（确保裁剪区域在原始depoMap范围内）
    offset_x = max(0, min(offset_x, depo_shape[0] - simu_shape[0]))
    offset_y = max(0, min(offset_y, depo_shape[1] - simu_shape[1]))
    offset_z = max(0, min(offset_z, depo_shape[2] - simu_shape[2]))
    
    # 执行裁剪操作
    cropped = depoMap[
        offset_x : offset_x + simu_shape[0],
        offset_y : offset_y + simu_shape[1],
        offset_z : offset_z + simu_shape[2]
    ]
    
    # 调试输出验证尺寸
    print(f"优化后裁剪尺寸: {cropped.shape}，理论目标尺寸: {simu_shape}")
    return cropped.numpy()
